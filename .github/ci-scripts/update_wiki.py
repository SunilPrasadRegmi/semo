import argparse
import json
import os
import subprocess
import tempfile
from datetime import datetime
from pathlib import Path


class WikiUpdater:
    def __init__(self, token, repo):
        self.token = token
        self.repo = repo
        self.wiki_url = f"https://{token}@github.com/{repo}.wiki.git"

    def clone_wiki(self, temp_dir):
        """Clone the wiki repository"""
        wiki_path = temp_dir / "wiki"
        try:
            subprocess.run([
                "git", "clone", self.wiki_url, str(wiki_path)
            ], check=True, capture_output=True)
        except subprocess.CalledProcessError:
            # Wiki might not exist yet, create it
            wiki_path.mkdir()
            os.chdir(wiki_path)
            subprocess.run(["git", "init"], check=True)
            subprocess.run(["git", "remote", "add", "origin", self.wiki_url], check=True)

        os.chdir(wiki_path)
        subprocess.run(["git", "config", "user.name", "GitHub Actions"], check=True)
        subprocess.run(["git", "config", "user.email", "actions@github.com"], check=True)

        return wiki_path

    def get_commit_info(self, commit_hash):
        """Get commit information"""
        result = subprocess.run([
            "git", "log", "-1", "--format=%H|%h|%an|%s|%ci", commit_hash
        ], capture_output=True, text=True, check=True)

        full_hash, short_hash, author, message, date = result.stdout.strip().split("|", 4)
        return {
            "full_hash": full_hash,
            "short_hash": short_hash,
            "author": author,
            "message": message,
            "date": date
        }

    def read_json_file(self, file_path):
        """Read and parse JSON file"""
        if not file_path or not os.path.exists(file_path):
            return {}

        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError):
            return {}

    def create_folder_structure(self):
        """Create organized folder structure in wiki"""
        folders = [
            "changelogs",
            "code-reviews",
            "failed-builds"
        ]

        for folder in folders:
            Path(folder).mkdir(parents=True, exist_ok=True)

    def create_changelog_page(self, commit_info, changelog_content):
        """Create changelog page"""
        short_hash = commit_info["short_hash"]
        date_str = datetime.now().strftime("%Y-%m-%d")

        content = f"""# Changelog: {short_hash}

**Commit:** [{short_hash}](https://github.com/{self.repo}/commit/{commit_info['full_hash']})  
**Date:** {commit_info['date']}
**Message:** {commit_info['message']}

## üìù Generated Changelog

{changelog_content}

---
*Auto-generated by GitHub Actions on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
"""

        file_path = f"changelogs/{date_str}-{short_hash}.md"
        with open(file_path, 'w') as f:
            f.write(content)

        return file_path

    def create_code_review_page(self, commit_info, code_review_content):
        """Create code review page"""
        short_hash = commit_info["short_hash"]
        date_str = datetime.now().strftime("%Y-%m-%d")

        content = f"""# Code Review: {short_hash}

**Commit:** [{short_hash}](https://github.com/{self.repo}/commit/{commit_info['full_hash']})  
**Date:** {commit_info['date']}
**Message:** {commit_info['message']}

## üîç Code Review Analysis

{code_review_content}

---
*Auto-generated by GitHub Actions on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
"""

        file_path = f"code-reviews/{date_str}-{short_hash}.md"
        with open(file_path, 'w') as f:
            f.write(content)

        return file_path

    def create_failure_page(self, commit_info, error_analysis_content, run_id):
        """Create failed build documentation page"""
        short_hash = commit_info["short_hash"]
        date_str = datetime.now().strftime("%Y-%m-%d")

        content = f"""# Build Failure Analysis: {short_hash}

**Commit:** [{short_hash}](https://github.com/{self.repo}/commit/{commit_info['full_hash']})  
**Date:** {commit_info['date']}
**Author:** {commit_info['author']}  
**Message:** {commit_info['message']}  
**Status:** ‚ùå Build Failed

## üö® Error Analysis

{error_analysis_content}

## üîó Links
- [View Commit](https://github.com/{self.repo}/commit/{commit_info['full_hash']})
- [GitHub Actions Run](https://github.com/{self.repo}/actions/runs/{run_id})

---
*Auto-generated by GitHub Actions on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
"""

        file_path = f"failed-builds/{date_str}-{short_hash}.md"
        with open(file_path, 'w') as f:
            f.write(content)

        return file_path

    def update_index_pages(self, commit_info, changelog_path, code_review_path):
        """Update the changelog and code review index pages"""
        # Update changelog index
        changelog_index = "changelogs/README.md"
        if not os.path.exists(changelog_index):
            with open(changelog_index, 'w') as f:
                f.write("""# Changelogs

## Recent Changelogs
""")

        # Add to changelog index
        with open(changelog_index, 'r') as f:
            lines = f.readlines()

        for i, line in enumerate(lines):
            if line.strip() == "## Recent Changelogs":
                new_entry = f"- [{commit_info['short_hash']} - {commit_info['message']}]({os.path.basename(changelog_path)}) ({commit_info['date'][:10]})\n"
                lines.insert(i + 1, new_entry)
                break

        with open(changelog_index, 'w') as f:
            f.writelines(lines)

        # Update code review index
        review_index = "code-reviews/README.md"
        if not os.path.exists(review_index):
            with open(review_index, 'w') as f:
                f.write("""# Code Reviews

## Recent Code Reviews
""")

        # Add to code review index
        with open(review_index, 'r') as f:
            lines = f.readlines()

        for i, line in enumerate(lines):
            if line.strip() == "## Recent Code Reviews":
                new_entry = f"- [{commit_info['short_hash']} - {commit_info['message']}]({os.path.basename(code_review_path)}) ({commit_info['date'][:10]})\n"
                lines.insert(i + 1, new_entry)
                break

        with open(review_index, 'w') as f:
            f.writelines(lines)

    def update_failure_index(self, commit_info, failure_path):
        """Update the failed builds index page"""
        failure_index = "failed-builds/README.md"
        if not os.path.exists(failure_index):
            with open(failure_index, 'w') as f:
                f.write("""# Failed Builds

## Recent Failures
""")

        # Add to failure index
        with open(failure_index, 'r') as f:
            lines = f.readlines()

        for i, line in enumerate(lines):
            if line.strip() == "## Recent Failures":
                new_entry = f"- [{commit_info['short_hash']} - {commit_info['message']}]({os.path.basename(failure_path)}) ‚ùå ({commit_info['date'][:10]})\n"
                lines.insert(i + 1, new_entry)
                break

        with open(failure_index, 'w') as f:
            f.writelines(lines)

    def update_home_page(self, commit_info, changelog_path=None, code_review_path=None, failure_path=None):
        """Update or create the home page"""
        home_file = "Home.md"

        if failure_path:
            # Failed build
            latest_link = f"[Latest Build (Failed)]({failure_path}) - {commit_info['short_hash']} ‚ùå"
        else:
            # Successful build
            latest_link = f"[Latest Changelog]({changelog_path}) - {commit_info['short_hash']}"

        content = f"""# Project Documentation

Welcome to the project documentation wiki!

## üìã Latest Updates
- {latest_link}

## üóÇÔ∏è Navigation
- [üìù Changelogs](changelogs/README) - All commit changelogs
- [üîç Code Reviews](code-reviews/README) - Automated code reviews
- [‚ùå Failed Builds](failed-builds/README) - Build failure analyses

## üìÅ Wiki Structure
- `changelogs/` - Generated changelogs for each commit
- `code-reviews/` - Automated code review summaries  
- `failed-builds/` - Build failure documentation

---
*Last updated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
"""

        with open(home_file, 'w') as f:
            f.write(content)

    def commit_and_push(self, commit_info, is_success=True):
        """Commit and push changes to wiki"""
        status_text = "success" if is_success else "failure"
        commit_message = f"Add {status_text} documentation for commit {commit_info['short_hash']}: {commit_info['message']}"

        subprocess.run(["git", "add", "."], check=True)

        # Check if there are changes to commit
        result = subprocess.run(["git", "diff", "--staged", "--quiet"], capture_output=True)
        if result.returncode == 0:
            print("No changes to commit")
            return

        subprocess.run(["git", "commit", "-m", commit_message], check=True)

        try:
            subprocess.run(["git", "push", "origin", "master"], check=True)
        except subprocess.CalledProcessError:
            # Try main branch if master fails
            subprocess.run(["git", "push", "origin", "main"], check=True)

    def handle_success(self, commit_hash, changelog_file, code_review_file):
        """Handle successful build documentation"""
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            wiki_path = self.clone_wiki(temp_path)

            # Get commit info (from original repo, not wiki)
            original_cwd = os.getcwd()
            os.chdir(original_cwd)
            commit_info = self.get_commit_info(commit_hash)
            os.chdir(wiki_path)

            # Read generated content
            changelog_data = self.read_json_file(changelog_file)
            code_review_data = self.read_json_file(code_review_file)

            changelog_content = changelog_data.get('changelog', 'No changelog generated')
            code_review_content = code_review_data.get('code_review', 'No code review generated')

            # Create folder structure
            self.create_folder_structure()

            # Create separate pages
            changelog_path = self.create_changelog_page(commit_info, changelog_content)
            code_review_path = self.create_code_review_page(commit_info, code_review_content)

            # Update index pages
            self.update_index_pages(commit_info, changelog_path, code_review_path)
            self.update_home_page(commit_info, changelog_path, code_review_path)

            # Commit and push
            self.commit_and_push(commit_info, is_success=True)

            print(f"Successfully updated wiki for commit {commit_info['short_hash']}")

    def handle_failure(self, commit_hash, error_analysis_file, run_id):
        """Handle failed build documentation"""
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            wiki_path = self.clone_wiki(temp_path)

            # Get commit info (from original repo, not wiki)
            original_cwd = os.getcwd()
            os.chdir(original_cwd)
            commit_info = self.get_commit_info(commit_hash)
            os.chdir(wiki_path)

            # Read error analysis
            error_data = self.read_json_file(error_analysis_file)
            error_content = error_data.get('error_analysis', 'Build failed but no error analysis was generated.')

            # Create folder structure
            self.create_folder_structure()

            # Create failure page
            failure_path = self.create_failure_page(commit_info, error_content, run_id)

            # Update index pages
            self.update_failure_index(commit_info, failure_path)
            self.update_home_page(commit_info, failure_path=failure_path)

            # Commit and push
            self.commit_and_push(commit_info, is_success=False)

            print(f"Successfully updated wiki with failure analysis for commit {commit_info['short_hash']}")


def main():
    parser = argparse.ArgumentParser(description='Update GitHub wiki with build documentation')
    parser.add_argument('--token', required=True, help='GitHub token')
    parser.add_argument('--repo', required=True, help='Repository name (owner/repo)')
    parser.add_argument('--commit-hash', required=True, help='Commit hash')
    parser.add_argument('--run-id', help='GitHub Actions run ID (for failures)')

    # File arguments
    parser.add_argument('--changelog-file', help='Path to changelog JSON file')
    parser.add_argument('--code-review-file', help='Path to code review JSON file')
    parser.add_argument('--error-analysis-file', help='Path to error analysis JSON file')

    # Mode arguments
    parser.add_argument('--success', action='store_true', help='Handle successful build')
    parser.add_argument('--failure', action='store_true', help='Handle failed build')

    args = parser.parse_args()

    updater = WikiUpdater(args.token, args.repo)

    if args.success:
        updater.handle_success(args.commit_hash, args.changelog_file, args.code_review_file)
    elif args.failure:
        updater.handle_failure(args.commit_hash, args.error_analysis_file, args.run_id)
    else:
        print("Must specify either --success or --failure")
        return 1

    return 0


if __name__ == "__main__":
    exit(main())